<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#1a1a2e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>No_Gas_Labs‚Ñ¢ Celebrity Deathmatch</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #e94560;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      font-size: 2rem;
      margin-bottom: 30px;
      text-shadow: 0 0 10px #e94560;
      word-wrap: break-word;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-top: 30px;
    }

    button {
      background: #0f3460;
      color: #e94560;
      border: 2px solid #e94560;
      padding: 22px 30px;
      font-size: 1.2rem;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      min-height: 44px;
      min-width: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      text-transform: uppercase;
      font-weight: bold;
    }

    button:hover {
      background: #e94560;
      color: #0f3460;
      box-shadow: 0 0 20px #e94560;
    }

    button:active {
      transform: scale(0.95);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }

    #status {
      text-align: center;
      margin-top: 30px;
      padding: 20px;
      background: rgba(15, 52, 96, 0.5);
      border: 2px solid #e94560;
      min-height: 100px;
    }

    .stats {
      text-align: center;
      margin-top: 20px;
      font-size: 0.9rem;
      color: #aaa;
    }

    @media (max-width: 480px) {
      h1 {
        font-size: 1.5rem;
      }
      
      button {
        font-size: 1rem;
        padding: 18px 24px;
      }
    }

    .fighters-grid {
      display: none;
      margin-top: 30px;
    }

    .fighters-grid h2 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 1.5rem;
    }

    #fightersList {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 15px;
    }

    .fighter-card {
      background: rgba(15, 52, 96, 0.8);
      border: 2px solid #e94560;
      padding: 15px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      min-height: 200px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .fighter-card:hover {
      background: #e94560;
      color: #0f3460;
      transform: scale(1.05);
    }

    .fighter-card.selected {
      background: #e94560;
      color: #0f3460;
      box-shadow: 0 0 20px #e94560;
    }

    .fighter-name {
      font-size: 1.1rem;
      font-weight: bold;
      margin-bottom: 10px;
      word-wrap: break-word;
    }

    .fighter-stats {
      font-size: 0.8rem;
      text-align: left;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      margin: 3px 0;
    }

    .fighter-xp {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #e94560;
      font-size: 0.75rem;
    }

    .back-btn {
      background: #0f3460;
      color: #e94560;
      border: 2px solid #e94560;
      padding: 15px 25px;
      margin-top: 20px;
      width: 100%;
      min-height: 44px;
    }

    .battle-arena {
      display: none;
      margin-top: 20px;
      padding: 20px;
      background: rgba(15, 52, 96, 0.9);
      border: 2px solid #e94560;
    }

    .battle-header h2 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 1.3rem;
    }

    .fighters-battle {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      gap: 10px;
    }

    .fighter-side {
      flex: 1;
      text-align: center;
      --jitter-x: 0px;
      --jitter-y: 0px;
      --jitter-rot: 0deg;
      --impact-scale: 1;
      transform: translate(var(--jitter-x), var(--jitter-y)) rotate(var(--jitter-rot)) scale(var(--impact-scale));
      transition: transform 0.08s steps(2);
    }

    .fighter-info h3 {
      font-size: 1.2rem;
      margin-bottom: 10px;
      word-wrap: break-word;
    }

    .hp-bar {
      background: #1a1a2e;
      border: 2px solid #e94560;
      height: 20px;
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
    }

    .hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #e94560, #ff6b6b);
      transition: width 0.3s ease;
    }

    .energy-bar {
      background: #101828;
      border: 2px solid #46e5a6;
      height: 12px;
      border-radius: 8px;
      overflow: hidden;
      margin: 8px 0 6px;
    }

    .energy-fill {
      height: 100%;
      background: linear-gradient(90deg, #46e5a6, #8bffd6);
      transition: width 0.2s ease;
    }

    .energy-text {
      font-size: 0.75rem;
      color: #8bffd6;
    }

    .vs-divider {
      font-size: 2rem;
      font-weight: bold;
      color: #e94560;
      text-shadow: 0 0 10px #e94560;
    }

    .battle-log {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #e94560;
      padding: 15px;
      height: 150px;
      overflow-y: auto;
      margin-bottom: 15px;
      font-size: 0.9rem;
    }

    .battle-log p {
      margin: 5px 0;
      line-height: 1.4;
    }

    .battle-actions {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .battle-actions button {
      flex: 1;
      padding: 18px 20px;
      font-size: 1rem;
    }

    @media print {
      body {
        background: white;
        color: black;
      }
      
      button {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>No_Gas_Labs‚Ñ¢<br>Celebrity Deathmatch</h1>
    
    <div id="status">
      <p>Ready to rumble!</p>
      <p>Iteration: 4 - Real-Time Combat Active</p>
    </div>
    
    <div id="fightersGrid" class="fighters-grid" style="display: none;">
      <h2>Select Your Fighter</h2>
      <div id="fightersList"></div>
    </div>

    <div id="battleArena" class="battle-arena" style="display: none;">
      <div class="battle-header">
        <h2>‚öîÔ∏è BATTLE ARENA ‚öîÔ∏è</h2>
      </div>
      
      <div class="fighters-battle">
        <div class="fighter-side player-side">
          <div class="fighter-info">
            <h3 id="playerName">Player</h3>
            <div class="hp-bar">
              <div class="hp-fill" id="playerHP"></div>
            </div>
            <p id="playerHPText">HP: 100/100</p>
            <div class="energy-bar">
              <div class="energy-fill" id="playerEnergy"></div>
            </div>
            <p class="energy-text" id="playerEnergyText">Energy: 0%</p>
          </div>
        </div>
        
        <div class="vs-divider">VS</div>
        
        <div class="fighter-side enemy-side">
          <div class="fighter-info">
            <h3 id="enemyName">Enemy</h3>
            <div class="hp-bar">
              <div class="hp-fill" id="enemyHP"></div>
            </div>
            <p id="enemyHPText">HP: 100/100</p>
            <div class="energy-bar">
              <div class="energy-fill" id="enemyEnergy"></div>
            </div>
            <p class="energy-text" id="enemyEnergyText">Energy: 0%</p>
          </div>
        </div>
      </div>
      
      <div id="battleLog" class="battle-log">
        <p>Select an opponent to start!</p>
      </div>
      
      <div id="battleActions" class="battle-actions">
        <button onclick="attackAction()" id="attackBtn">Attack</button>
        <button onclick="specialAction()" id="specialBtn">Special</button>
        <button onclick="healAction()" id="healBtn">Heal</button>
      </div>
      
      <button class="back-btn" onclick="endBattle()">End Battle</button>
    </div>

    <div class="controls">
      <button id="exportBtn" onclick="exportData()">Export Data</button>
      <button id="importBtn" onclick="importData()">Import Data</button>
      <button id="resetBtn" onclick="resetData()">Reset Data</button>
      <button id="fightersBtn" onclick="showFighters()">Fighters</button>
      <button id="battleBtn" onclick="startBattle()">Battle</button>
    </div>
    
    <div class="stats">
      <p>Version: 1.0.0-iter-4</p>
      <p>Offline-capable | No dependencies</p>
    </div>
  </div>

  <script>
    // No_Gas_Labs‚Ñ¢ Celebrity Deathmatch - Core Infrastructure
    // Ralph Loop Iteration 4
    // Zero external dependencies - localStorage powered

    const STORAGE_KEY = 'ngl_deathmatch_data';
    const VERSION = '1.0.0-iter-4';

    // Fighter Database
    const FIGHTERS = [
      {
        id: 1,
        name: 'The Rock',
        type: 'Brawler',
        hp: 150,
        attack: 25,
        defense: 20,
        speed: 15,
        special: 'Rock Bottom',
        xp: 0,
        level: 1,
        wins: 0,
        losses: 0
      },
      {
        id: 2,
        name: 'Elon Musk',
        type: 'Tech',
        hp: 100,
        attack: 35,
        defense: 10,
        speed: 25,
        special: 'To The Moon',
        xp: 0,
        level: 1,
        wins: 0,
        losses: 0
      },
      {
        id: 3,
        name: 'Taylor Swift',
        type: 'Pop Star',
        hp: 120,
        attack: 30,
        defense: 15,
        speed: 20,
        special: 'Shake It Off',
        xp: 0,
        level: 1,
        wins: 0,
        losses: 0
      },
      {
        id: 4,
        name: 'Keanu Reeves',
        type: 'Action Hero',
        hp: 140,
        attack: 28,
        defense: 22,
        speed: 18,
        special: 'Matrix Dodge',
        xp: 0,
        level: 1,
        wins: 0,
        losses: 0
      },
      {
        id: 5,
        name: 'Gordon Ramsay',
        type: 'Chef',
        hp: 110,
        attack: 32,
        defense: 12,
        speed: 22,
        special: 'RAGE QUIT',
        xp: 0,
        level: 1,
        wins: 0,
        losses: 0
      },
      {
        id: 6,
        name: 'Dwayne Johnson',
        type: 'Brawler',
        hp: 160,
        attack: 22,
        defense: 25,
        speed: 12,
        special: 'People\'s Elbow',
        xp: 0,
        level: 1,
        wins: 0,
        losses: 0
      }
    ];

    let selectedFighter = null;
    let battleState = {
      active: false,
      player: null,
      enemy: null,
      playerHP: 0,
      enemyHP: 0,
      playerMaxHP: 0,
      enemyMaxHP: 0,
      playerEnergy: 0,
      enemyEnergy: 0,
      playerStunTicks: 0,
      enemyStunTicks: 0,
      specialCooldown: 0,
      healCooldown: 0,
      enemySpecialCooldown: 0,
      enemyHealCooldown: 0
    };

    let heartbeatInterval = null;
    let renderInterval = null;

    // Initialize on load
    window.onload = function() {
      console.log('No_Gas_Labs‚Ñ¢ Deathmatch initialized');
      console.log('Version:', VERSION);
      console.log('Iteration: 4');
      console.log('Fighters loaded:', FIGHTERS.length);
      loadData();
    };

    // localStorage functions
    function saveData(data) {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        console.log('Data saved successfully');
        return true;
      } catch (e) {
        console.error('Save failed:', e);
        alert('Save failed: ' + e.message);
        return false;
      }
    }

    function loadData() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
          const data = JSON.parse(stored);
          console.log('Data loaded:', data);
          
          // Restore selected fighter
          if (data.selectedFighterId) {
            selectedFighter = FIGHTERS.find(f => f.id === data.selectedFighterId);
          }
          
          return data;
        } else {
          console.log('No saved data found');
          return null;
        }
      } catch (e) {
        console.error('Load failed:', e);
        return null;
      }
    }

    // Export function
    function exportData() {
      try {
        const data = loadData() || { version: VERSION, timestamp: Date.now() };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `deathmatch-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        updateStatus('Data exported successfully!');
        console.log('Export successful');
      } catch (e) {
        console.error('Export failed:', e);
        alert('Export failed: ' + e.message);
      }
    }

    // Import function
    function importData() {
      try {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = function(e) {
          const file = e.target.files[0];
          const reader = new FileReader();
          reader.onload = function(e) {
            try {
              const data = JSON.parse(e.target.result);
              if (saveData(data)) {
                updateStatus('Data imported successfully!');
                console.log('Import successful:', data);
              }
            } catch (err) {
              alert('Invalid JSON file: ' + err.message);
            }
          };
          reader.readAsText(file);
        };
        input.click();
      } catch (e) {
        console.error('Import failed:', e);
        alert('Import failed: ' + e.message);
      }
    }

    // Reset function
    function resetData() {
      if (confirm('Are you sure you want to reset all data? This cannot be undone!')) {
        try {
          localStorage.removeItem(STORAGE_KEY);
          updateStatus('Data reset successfully!');
          console.log('Reset successful');
        } catch (e) {
          console.error('Reset failed:', e);
          alert('Reset failed: ' + e.message);
        }
      }
    }

    // Update status display
    function updateStatus(message) {
      const statusDiv = document.getElementById('status');
      statusDiv.innerHTML = '<p>' + message + '</p>';
    }

    // Show fighters grid
    function showFighters() {
      const grid = document.getElementById('fightersGrid');
      const list = document.getElementById('fightersList');
      
      if (grid.style.display === 'none' || grid.style.display === '') {
        grid.style.display = 'block';
        renderFighters();
      } else {
        grid.style.display = 'none';
      }
    }

    // Render fighters list
    function renderFighters() {
      const list = document.getElementById('fightersList');
      const savedData = loadData();
      
      list.innerHTML = FIGHTERS.map(fighter => {
        const savedFighter = savedData?.fighters?.find(f => f.id === fighter.id);
        const currentFighter = savedFighter || fighter;
        const isSelected = selectedFighter && selectedFighter.id === currentFighter.id;
        
        return `
          <div class="fighter-card ${isSelected ? 'selected' : ''}" onclick="selectFighter(${currentFighter.id})">
            <div>
              <div class="fighter-name">${currentFighter.name}</div>
              <div class="fighter-stats">
                <div class="stat-row"><span>HP:</span><span>${currentFighter.hp}</span></div>
                <div class="stat-row"><span>ATK:</span><span>${currentFighter.attack}</span></div>
                <div class="stat-row"><span>DEF:</span><span>${currentFighter.defense}</span></div>
                <div class="stat-row"><span>SPD:</span><span>${currentFighter.speed}</span></div>
              </div>
            </div>
            <div class="fighter-xp">
              <div>Lvl: ${currentFighter.level}</div>
              <div>XP: ${currentFighter.xp}</div>
              <div>W/L: ${currentFighter.wins}/${currentFighter.losses}</div>
            </div>
          </div>
        `;
      }).join('') + `
        <button class="back-btn" onclick="hideFighters()">Back</button>
      `;
    }

    // Hide fighters grid
    function hideFighters() {
      const grid = document.getElementById('fightersGrid');
      grid.style.display = 'none';
    }

    // Select fighter
    function selectFighter(id) {
      const fighter = FIGHTERS.find(f => f.id === id);
      if (fighter) {
        selectedFighter = fighter;
        renderFighters();
        updateStatus(`Selected: ${fighter.name}`);
        console.log('Fighter selected:', fighter.name);
        
        // Save selection
        const data = loadData() || {};
        data.selectedFighterId = id;
        saveData(data);
      }
    }

    // Start battle
    function startBattle() {
      if (!selectedFighter) {
        alert('Please select a fighter first!');
        return;
      }

      // Select random enemy
      const enemies = FIGHTERS.filter(f => f.id !== selectedFighter.id);
      const enemy = enemies[Math.floor(Math.random() * enemies.length)];

      // Initialize battle state
      battleState = {
        active: true,
        player: { ...selectedFighter },
        enemy: { ...enemy },
        playerHP: selectedFighter.hp,
        enemyHP: enemy.hp,
        playerMaxHP: selectedFighter.hp,
        enemyMaxHP: enemy.hp,
        playerEnergy: 0,
        enemyEnergy: 0,
        playerStunTicks: 0,
        enemyStunTicks: 0,
        specialCooldown: 0,
        healCooldown: 0,
        enemySpecialCooldown: 0,
        enemyHealCooldown: 0
      };

      // Show battle arena
      document.getElementById('fightersGrid').style.display = 'none';
      document.getElementById('battleArena').style.display = 'block';
      document.getElementById('battleLog').innerHTML = '';

      // Update UI
      updateBattleUI();
      addBattleLog(`‚öîÔ∏è ${battleState.player.name} vs ${battleState.enemy.name}!`);
      addBattleLog('Battle starts! Build energy and strike fast.');

      startBattleLoops();

      // Save state
      const data = loadData() || {};
      data.battleState = battleState;
      saveData(data);

      console.log('Battle started:', battleState.player.name, 'vs', battleState.enemy.name);
    }

    // Update battle UI
    function updateBattleUI() {
      document.getElementById('playerName').textContent = battleState.player.name;
      document.getElementById('enemyName').textContent = battleState.enemy.name;
      
      const playerPercent = (battleState.playerHP / battleState.playerMaxHP) * 100;
      const enemyPercent = (battleState.enemyHP / battleState.enemyMaxHP) * 100;
      
      document.getElementById('playerHP').style.width = `${Math.max(0, playerPercent)}%`;
      document.getElementById('enemyHP').style.width = `${Math.max(0, enemyPercent)}%`;
      
      document.getElementById('playerHPText').textContent = `HP: ${Math.max(0, battleState.playerHP)}/${battleState.playerMaxHP}`;
      document.getElementById('enemyHPText').textContent = `HP: ${Math.max(0, battleState.enemyHP)}/${battleState.enemyMaxHP}`;

      const playerEnergyPercent = Math.min(100, (battleState.playerEnergy / 100) * 100);
      const enemyEnergyPercent = Math.min(100, (battleState.enemyEnergy / 100) * 100);

      document.getElementById('playerEnergy').style.width = `${playerEnergyPercent}%`;
      document.getElementById('enemyEnergy').style.width = `${enemyEnergyPercent}%`;
      document.getElementById('playerEnergyText').textContent = `Energy: ${Math.floor(playerEnergyPercent)}%`;
      document.getElementById('enemyEnergyText').textContent = `Energy: ${Math.floor(enemyEnergyPercent)}%`;

      const canAct = battleState.playerEnergy >= 100;

      // Update button states
      document.getElementById('attackBtn').disabled = !canAct;
      document.getElementById('specialBtn').disabled = !canAct || battleState.specialCooldown > 0;
      document.getElementById('specialBtn').textContent = battleState.specialCooldown > 0 ? 
        `Special (${battleState.specialCooldown})` : 'Special';
      
      document.getElementById('healBtn').disabled = !canAct || battleState.healCooldown > 0;
      document.getElementById('healBtn').textContent = battleState.healCooldown > 0 ? 
        `Heal (${battleState.healCooldown})` : 'Heal';
    }

    // Add battle log message
    function addBattleLog(message) {
      const log = document.getElementById('battleLog');
      const p = document.createElement('p');
      p.textContent = message;
      log.appendChild(p);
      log.scrollTop = log.scrollHeight;
    }

    // Calculate damage
    function calculateDamage(attacker, defender, isSpecial = false) {
      const baseDamage = attacker.attack;
      const defense = defender.defense;
      const multiplier = isSpecial ? 1.5 : 1.0;
      
      const variance = 0.8 + Math.random() * 0.4; // 80-120% variance
      const damage = Math.floor((baseDamage - defense * 0.5) * multiplier * variance);
      
      return Math.max(1, damage);
    }

    function applyJitter() {
      const playerSide = document.querySelector('.player-side');
      const enemySide = document.querySelector('.enemy-side');

      if (!playerSide || !enemySide) return;

      playerSide.style.setProperty('--jitter-x', `${(Math.random() - 0.5) * 6}px`);
      playerSide.style.setProperty('--jitter-y', `${(Math.random() - 0.5) * 6}px`);
      playerSide.style.setProperty('--jitter-rot', `${(Math.random() - 0.5) * 2}deg`);

      enemySide.style.setProperty('--jitter-x', `${(Math.random() - 0.5) * 6}px`);
      enemySide.style.setProperty('--jitter-y', `${(Math.random() - 0.5) * 6}px`);
      enemySide.style.setProperty('--jitter-rot', `${(Math.random() - 0.5) * 2}deg`);
    }

    function triggerImpact(side) {
      const element = document.querySelector(`.${side}-side`);
      if (!element) return;

      element.style.setProperty('--impact-scale', '1.06');
      setTimeout(() => {
        element.style.setProperty('--impact-scale', '1');
      }, 160);
    }

    function applyDamage(attacker, defenderKey, damage) {
      const maxHPKey = `${defenderKey}MaxHP`;
      const hpKey = `${defenderKey}HP`;

      battleState[hpKey] -= damage;
      const stunThreshold = Math.max(12, Math.floor(battleState[maxHPKey] * 0.15));
      if (damage >= stunThreshold) {
        battleState[`${defenderKey}StunTicks`] = 1;
        addBattleLog(`üí´ ${defenderKey === 'enemy' ? battleState.enemy.name : battleState.player.name} is stunned!`);
      }
      triggerImpact(defenderKey);
    }

    function heartbeat() {
      if (!battleState.active) return;

      if (battleState.specialCooldown > 0) battleState.specialCooldown--;
      if (battleState.healCooldown > 0) battleState.healCooldown--;
      if (battleState.enemySpecialCooldown > 0) battleState.enemySpecialCooldown--;
      if (battleState.enemyHealCooldown > 0) battleState.enemyHealCooldown--;

      if (battleState.playerStunTicks > 0) {
        battleState.playerStunTicks--;
      } else {
        battleState.playerEnergy = Math.min(120, battleState.playerEnergy + Math.max(5, battleState.player.speed * 2));
      }

      if (battleState.enemyStunTicks > 0) {
        battleState.enemyStunTicks--;
      } else {
        battleState.enemyEnergy = Math.min(120, battleState.enemyEnergy + Math.max(5, battleState.enemy.speed * 2));
      }

      if (battleState.enemyEnergy >= 100) {
        executeEnemyMove();
        battleState.enemyEnergy = 0;
      }

      if (battleState.playerHP <= 0) {
        endBattle(false);
        return;
      }

      if (battleState.enemyHP <= 0) {
        endBattle(true);
      }
    }

    function startBattleLoops() {
      stopBattleLoops();
      heartbeatInterval = setInterval(heartbeat, 600);
      renderInterval = setInterval(() => {
        if (!battleState.active) return;
        applyJitter();
        updateBattleUI();
      }, 1000 / 12);
    }

    function stopBattleLoops() {
      if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
        heartbeatInterval = null;
      }
      if (renderInterval) {
        clearInterval(renderInterval);
        renderInterval = null;
      }
    }

    // Attack action
    function attackAction() {
      if (!battleState.active || battleState.playerEnergy < 100) return;

      const damage = calculateDamage(battleState.player, battleState.enemy);
      battleState.playerEnergy = 0;
      
      addBattleLog(`üí• ${battleState.player.name} attacks for ${damage} damage!`);
      applyDamage(battleState.player, 'enemy', damage);
      
      if (battleState.enemyHP <= 0) {
        endBattle(true);
        return;
      }
    }

    // Special action
    function specialAction() {
      if (!battleState.active || battleState.playerEnergy < 100 || battleState.specialCooldown > 0) return;

      const damage = calculateDamage(battleState.player, battleState.enemy, true);
      battleState.playerEnergy = 0;
      battleState.specialCooldown = 3;
      
      addBattleLog(`‚ö° ${battleState.player.name} uses ${battleState.player.special} for ${damage} damage!`);
      applyDamage(battleState.player, 'enemy', damage);
      
      if (battleState.enemyHP <= 0) {
        endBattle(true);
        return;
      }
    }

    // Heal action
    function healAction() {
      if (!battleState.active || battleState.playerEnergy < 100 || battleState.healCooldown > 0) return;

      const healAmount = Math.floor(battleState.playerMaxHP * 0.3);
      battleState.playerHP = Math.min(battleState.playerMaxHP, battleState.playerHP + healAmount);
      battleState.playerEnergy = 0;
      battleState.healCooldown = 3;
      
      addBattleLog(`üíö ${battleState.player.name} heals for ${healAmount} HP!`);
      triggerImpact('player');
    }

    function executeEnemyMove() {
      if (!battleState.active || battleState.enemyHP <= 0) return;

      const action = Math.random();
      const canSpecial = battleState.enemySpecialCooldown === 0;
      const canHeal = battleState.enemyHealCooldown === 0;

      if (action < 0.65 || (!canSpecial && !canHeal)) {
        const damage = calculateDamage(battleState.enemy, battleState.player);
        applyDamage(battleState.enemy, 'player', damage);
        addBattleLog(`üí• ${battleState.enemy.name} attacks for ${damage} damage!`);
      } else if (action < 0.85 && canSpecial) {
        const damage = calculateDamage(battleState.enemy, battleState.player, true);
        battleState.enemySpecialCooldown = 3;
        applyDamage(battleState.enemy, 'player', damage);
        addBattleLog(`‚ö° ${battleState.enemy.name} uses ${battleState.enemy.special} for ${damage} damage!`);
      } else if (canHeal) {
        const healAmount = Math.floor(battleState.enemyMaxHP * 0.2);
        battleState.enemyHealCooldown = 3;
        battleState.enemyHP = Math.min(battleState.enemyMaxHP, battleState.enemyHP + healAmount);
        addBattleLog(`üíö ${battleState.enemy.name} heals for ${healAmount} HP!`);
        triggerImpact('enemy');
      }
    }

    // End battle
    function endBattle(playerWon = null) {
      if (!battleState.active) return;

      if (playerWon === true) {
        const xpGained = 100;
        addBattleLog(`üéâ ${battleState.player.name} wins! +${xpGained} XP`);
        
        // Update fighter stats
        const data = loadData() || {};
        if (!data.fighters) data.fighters = [];
        
        let fighterIndex = data.fighters.findIndex(f => f.id === battleState.player.id);
        if (fighterIndex === -1) {
          data.fighters.push({ ...battleState.player });
          fighterIndex = data.fighters.length - 1;
        }
        
        data.fighters[fighterIndex].xp += xpGained;
        data.fighters[fighterIndex].wins += 1;
        
        // Level up check
        const xpNeeded = data.fighters[fighterIndex].level * 200;
        if (data.fighters[fighterIndex].xp >= xpNeeded) {
          data.fighters[fighterIndex].level++;
          data.fighters[fighterIndex].hp += 10;
          data.fighters[fighterIndex].attack += 2;
          data.fighters[fighterIndex].defense += 2;
          data.fighters[fighterIndex].speed += 1;
          addBattleLog(`üéä ${battleState.player.name} leveled up to level ${data.fighters[fighterIndex].level}!`);
        }
        
        saveData(data);
        
      } else if (playerWon === false) {
        addBattleLog(`üíÄ ${battleState.player.name} was defeated...`);
        
        const data = loadData() || {};
        if (!data.fighters) data.fighters = [];
        
        let fighterIndex = data.fighters.findIndex(f => f.id === battleState.player.id);
        if (fighterIndex === -1) {
          data.fighters.push({ ...battleState.player });
          fighterIndex = data.fighters.length - 1;
        }
        
        data.fighters[fighterIndex].losses += 1;
        saveData(data);
      } else {
        addBattleLog('Battle ended.');
      }

      battleState.active = false;
      stopBattleLoops();
      setTimeout(() => {
        document.getElementById('battleArena').style.display = 'none';
        updateStatus('Battle complete!');
      }, 2000);

      console.log('Battle ended:', playerWon ? 'Player won' : 'Player lost');
    }

    // Service Worker registration for PWA (will be implemented later)
    if ('serviceWorker' in navigator) {
      console.log('Service Worker API available');
      // navigator.serviceWorker.register('/sw.js').catch(console.error);
    }

    // Prevent zoom on double-tap (mobile)
    document.addEventListener('dblclick', function(event) {
      event.preventDefault();
    }, { passive: false });

    // Prevent pull-to-refresh on mobile
    document.body.addEventListener('touchmove', function(e) {
      if (e.touches.length > 1) {
        e.preventDefault();
      }
    }, { passive: false });
  </script>
</body>
</html>
